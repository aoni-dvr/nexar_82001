#############################################################
#
# cavalry_lib
#
#############################################################

pkg			= CAVALRY_LIB

$(pkg)_VERSION		= 1.0
$(pkg)_SITE_METHOD	= local
$(pkg)_SITE		= $(AMBARELLA_PKG_DIR)/cavalry_lib
$(pkg)_SOURCE		= cavalry_lib-$($(pkg)_VERSION).tar.gz
$(pkg)_DEPENDENCIES	=
$(pkg)_INSTALL_STAGING	= NO
$(pkg)_INSTALL_IMAGES	= NO
$(pkg)_INSTALL_TARGET	= YES
$(pkg)_LICENSE		= MIT
$(pkg)_LICENSE_FILES	= License_MIT.txt

#Prepre command line for sub packages
ifeq ($(BR2_PACKAGE_CAVALRY_LIB),y)
  $(pkg)_INSTALL_STAGING = YES
  INSTALL_CAVALRY_FIRMWARE = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/firmware_cavalry -f br.mk DESTDIR=$(TARGET_DIR) install
  BUILD_CAVALRY_FIRMWARE = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/firmware_cavalry -f br.mk
  CLEAN_CAVALRY_FIRMWARE = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/firmware_cavalry -f br.mk clean
  INSTALL_STAGING_CAVALRY_FIRMWARE = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/firmware_cavalry -f br.mk DESTDIR=$(STAGING_DIR) lib_install
  UNINSTALL_STAGING_CAVALRY_FIRMWARE = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/firmware_cavalry -f br.mk DESTDIR=$(STAGING_DIR) lib_uninstall
else
  INSTALL_CAVALRY_FIRMWARE =
  BUILD_CAVALRY_FIRMWARE =
  CLEAN_CAVALRY_FIRMWARE =
  INSTALL_STAGING_CAVALRY_FIRMWARE =
  UNINSTALL_STAGING_CAVALRY_FIRMWARE =
endif

ifeq ($(BR2_PACKAGE_CAVALRY_MEM),y)
  $(pkg)_INSTALL_STAGING = YES
  INSTALL_CAVALRY_MEM = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/cavalry_mem -f br.mk DESTDIR=$(TARGET_DIR) install
  BUILD_CAVALRY_MEM = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/cavalry_mem -f br.mk
  CLEAN_CAVALRY_MEM = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/cavalry_mem -f br.mk clean
  INSTALL_STAGING_CAVALRY_MEM = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/cavalry_mem -f br.mk DESTDIR=$(STAGING_DIR) lib_install
  UNINSTALL_STAGING_CAVALRY_MEM = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/cavalry_mem -f br.mk DESTDIR=$(STAGING_DIR) lib_uninstall
else
  INSTALL_CAVALRY_MEM =
  BUILD_CAVALRY_MEM =
  CLEAN_CAVALRY_MEM =
  INSTALL_STAGING_CAVALRY_MEM =
  UNINSTALL_STAGING_CAVALRY_MEM =
endif

ifeq ($(BR2_PACKAGE_NNCTRL),y)
  $(pkg)_INSTALL_STAGING = YES
  INSTALL_NNCTRL = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/nnctrl -f br.mk DESTDIR=$(TARGET_DIR) install
  BUILD_NNCTRL = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/nnctrl -f br.mk
  CLEAN_NNCTRL = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/nnctrl -f br.mk clean
  INSTALL_STAGING_NNCTRL = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/nnctrl -f br.mk DESTDIR=$(STAGING_DIR) lib_install
  UNINSTALL_STAGING_NNCTRL = $(TARGET_CONFIGURE_OPTS) $(TARGET_MAKE_ENV) $(MAKE) -C $(@D)/nnctrl -f br.mk DESTDIR=$(STAGING_DIR) lib_uninstall
else
  INSTALL_NNCTRL =
  BUILD_NNCTRL =
  CLEAN_NNCTRL =
  INSTALL_STAGING_NNCTRL =
  UNINSTALL_STAGING_NNCTRL =
endif

#BuildRoot macro
define CAVALRY_LIB_INSTALL_TARGET_CMDS
  $(INSTALL_CAVALRY_FIRMWARE)
  $(INSTALL_CAVALRY_MEM)
  $(INSTALL_NNCTRL)  
endef

define CAVALRY_LIB_BUILD_CMDS
  $(BUILD_CAVALRY_FIRMWARE)
  $(BUILD_CAVALRY_MEM)
  $(BUILD_NNCTRL)  
endef

define CAVALRY_LIB_CLEAN_CMDS
  $(CLEAN_CAVALRY_FIRMWARE)
  $(CLEAN_CAVALRY_MEM)
  $(CLEAN_NNCTRL)   
endef

define CAVALRY_LIB_INSTALL_STAGING_CMDS
  $(INSTALL_STAGING_CAVALRY_FIRMWARE)
  $(INSTALL_STAGING_CAVALRY_MEM)
  $(INSTALL_STAGING_NNCTRL)  
endef

define CAVALRY_LIB_UNINSTALL_STAGING_CMDS
  $(UNINSTALL_STAGING_CAVALRY_FIRMWARE)
  $(UNINSTALL_STAGING_CAVALRY_MEM)
  $(UNINSTALL_STAGING_NNCTRL)
endef

define CAVALRY_LIB_POST_LEGAL_INFO_HOOKS_CMD
	@$(foreach F,$($(PKG)_LICENSE_FILES),$(call legal-license-file,$$($(PKG)_RAWNAME),$(F),$$($(PKG)_DIR)/$(F))$$(sep))
endef
CAVALRY_LIB_POST_LEGAL_INFO_HOOKS += CAVALRY_LIB_POST_LEGAL_INFO_HOOKS_CMD

$(eval $(generic-package))
