=== 1 Kbuild

"kbuild" is the build system used by the Linux kernel. It has perfect dependence check for the cases,
compiler flags change, source files change, menuconfig and .config changes. Compile or configure a module
is very simple by add a Makfile or Kconfig for that module.
Ambarella build environment benefits kbuild and customize it to build RTOS SDK on cygwin and linux machine.

The customized kbuild environment includes below parts. This is the minumum set of kbuild

 include/
    Auto generated include files used by kbuild.

 Kconfig
   Top Kconfig file.

 Makefile
   Top Makefile.

 scripts/
   Common rules etc. for all kbuild Makefiles.

 .config
   Kernel configuration needs to be generated by make menuconfig or make xxx_defconfig

=== 2 Kbuild example

Take FW programmer in ambassp as an example for users to easily understand how to build libraries and link
executable by kbuild. "make kbuild_defconfig && make" at top of kbuild to generate ambacamera.out, which is
used to program SYS partition.

=== 3 Kconfig

The configuration database is a collection of configuration options
organized in a tree structure:

	+- Code maturity level options
	|  +- Prompt for development and/or incomplete code/drivers
	+- Modules setup
	|  +- Networking support
	|  +- DSP support
	+- SOC
	|  +- FIO
	|  +- Peripheral
	+- ...

Every entry has its own dependencies. These dependencies are used
to determine the visibility of an entry. Any child entry is only
visible if its parent entry is also visible.

Please refer to original linux kbuild document, locates at Documentation/kconfig-language.txt.

=== 4 Makefiles

The Makefiles have five parts:

	Makefile			the top Makefile.
	.config				the kernel configuration file.
	scripts/arch/$(ARCH)/Makefile	the arch Makefile.
	scripts/Makefile.*		common rules etc. for all kbuild Makefiles.
	Makefiles			the Makefiles to specify objs and libraries for modules

The top Makefile reads the .config file, which comes from the kernel
configuration process.

The top Makefile is responsible for building executable and libraries.
It builds these goals by recursively descending into the subdirectories of
the kernel source tree.
The list of subdirectories which are visited depends upon the kernel
configuration. The top Makefile textually includes an arch Makefile
with the name scripts/arch/$(ARCH)/Makefile. The arch Makefile supplies
architecture-specific information to the top Makefile. For Ambarella,
it is specific to ARM.

Each subdirectory has a kbuild Makefile which carries out the commands
passed down from above. The kbuild Makefile uses information from the
.config file to construct various file lists used by kbuild to build
any libraries targets.

scripts/Makefile.* contains all the definitions/rules etc. that
are used to build the kernel based on the kbuild makefiles.

--- 4.1 Goal definitions

	Goal definitions are the main part (heart) of the kbuild Makefile.
	These lines define the files to be built, any special compilation
	options, and any subdirectories to be entered recursively.

	The most simple kbuild makefile contains one line:

	Example:
		obj-y += foo.o

	This tells kbuild that there is one object in that directory, named
	foo.o. foo.o will be built from foo.c or foo.S.

	Example:
		obj-$(CONFIG_FOO) += foo.o

	$(CONFIG_FOO) evaluates to either y or m (for module), which is not
	used in Ambarella RTOS SDK.
	If CONFIG_FOO is neither y nor m, then the file will not be compiled
	nor linked.


--- 4.2 Descending down in directories

	A Makefile is only responsible for building objects in its own
	directory. Files in subdirectories should be taken care of by
	Makefiles in these subdirs. The build system will automatically
	invoke make recursively in subdirectories, provided you let it know of
	them.

	To do so, obj-y is used.
	ext2 lives in a separate directory, and the Makefile present in fs/
	tells kbuild to descend down using the following assignment.

	Example:
		#SoC/A12/Makefile
		obj-y += AmbaSYS/src/

--- 4.3 Goal definition for a library

	Use obj-y to define a library goal. It's a MUST to have the library name with .a
	Use libname-objs to define the objs to consist of libname.a.
	Example shows to define AmbaSYS.a library which is consists of objs defined by
	AmbaSYS-objs variable.

	Example:
		obj-y += AmbaSYS.a
		AmbaSYS-objs := AmbaUtility.o
		AmbaSYS-objs += AmbaMemcpy_16to32.o AmbaMemcpy_32to16.o AmbaMemcpy_32to32.o AmbaMemcpy_32to8.o AmbaMemcpy_8to32.o

--- 4.4 Compilation flags

    ccflags-y, asflags-y and ldflags-y
	These three flags apply only to the kbuild makefile in which they
	are assigned. They are used for all the normal cc, as and ld
	invocations happening during a recursive build.
	Note: Flags with the same behaviour were previously named:
	EXTRA_CFLAGS, EXTRA_AFLAGS and EXTRA_LDFLAGS.
	They are still supported but their usage is deprecated.

	ccflags-y specifies options for compiling with $(CC).

	Example:
		# drivers/acpi/Makefile
		ccflags-y := -Os
		ccflags-$(CONFIG_ACPI_DEBUG) += -DACPI_DEBUG_OUTPUT

	This variable is necessary because the top Makefile owns the
	variable $(KBUILD_CFLAGS) and uses it for compilation flags for the
	entire tree.

	asflags-y specifies options for assembling with $(AS).

	Example:
		#arch/sparc/kernel/Makefile
		asflags-y := -ansi

	ldflags-y specifies options for linking with $(LD).

	Example:
		#arch/cris/boot/compressed/Makefile
		ldflags-y += -T $(srctree)/$(src)/decompress_$(arch-y).lds

    subdir-ccflags-y, subdir-asflags-y
	The two flags listed above are similar to ccflags-y and asflags-y.
	The difference is that the subdir- variants have effect for the kbuild
	file where they are present and all subdirectories.
	Options specified using subdir-* are added to the commandline before
	the options specified using the non-subdir variants.

	Example:
		subdir-ccflags-y := -Werror

    CFLAGS_$@, AFLAGS_$@

	CFLAGS_$@ and AFLAGS_$@ only apply to commands in current
	kbuild makefile.

	$(CFLAGS_$@) specifies per-file options for $(CC).  The $@
	part has a literal value which specifies the file that it is for.

	Example:
		# drivers/scsi/Makefile
		CFLAGS_aha152x.o =   -DAHA152X_STAT -DAUTOCONF
		CFLAGS_gdth.o    = # -DDEBUG_GDTH=2 -D__SERIAL__ -D__COM2__ \
				     -DGDTH_STATISTICS

	These two lines specify compilation flags for aha152x.o and gdth.o.

	$(AFLAGS_$@) is a similar feature for source files in assembly
	languages.

	Example:
		# arch/arm/kernel/Makefile
		AFLAGS_head.o        := -DTEXT_OFFSET=$(TEXT_OFFSET)
		AFLAGS_crunch-bits.o := -Wa,-mcpu=ep9312
		AFLAGS_iwmmxt.o      := -Wa,-mcpu=iwmmxt

--- 4.5 Building non-kbuild targets

    extra-y

	extra-y specify additional targets created in the current
	directory, in addition to any targets specified by obj-*.

	Listing all targets in extra-y is required for two purposes:
	1) Enable kbuild to check changes in command lines
	   - When $(call if_changed,xxx) is used
	2) kbuild knows what files to delete during "make clean"

	Example:
		#arch/x86/kernel/Makefile
		extra-y := head.o init_task.o

	In this example, extra-y is used to list object files that
	shall be built, but shall not be archieved as part of library
	target in the directory.


For more details, please refer to original linux kbuild document, locates at Documentation/makefiles.txt.

=== 5 Build commands

# Build all
make kbuild_defconfig
make

#
# make install
#
##########################################
# Example of app/Makefile
# obj-y := libA.a
# obj-y += libB.a libC.a
#
# libA-objs := a.o
# libB-objs := b.o
# libC-objs := c.o
#
# install-files := libA.a libB.a
# # No install-path is defined, default path is used. ($(srctree)/vendors/ambarella/lib)
# # Should be the full path
# install-path :=$(srctree)/vendors/mylib
#
# define INSTALL_POST_CMDS
# 	@echo "my INSTALL_CMDS start ................................"
# 	cp -f $(obj)/libC.a $(install-path)/
# 	@ls $(install-path) -la
# 	@echo "my INSTALL_CMDS end   ................................"
# endef
###########################################

# build libapp and install libs
make app-install

# build libapp
make app/

# Clean
make clean

# Arbitrary dir clean. "yourdir" is a target.
make yourdir-clean

# For example
make ssp/threadx-clean

# Add clean-files and clean-dirs in yourdir Makefile to have your own clean method

# Distclean
make distclean

# Single build for a dir with command line details
make V=1 ambassp/SoC/A12/Cortex/src/ or
make V=1 ambassp/SoC/A12/Cortex/src/ -j1

# Single build for a file
make ambassp/SoC/A12/Cortex/src/AmbaRTSL_Cache_ARM11.o

# Build for multiple files in a dir
make ambassp/SoC/A12/Cortex/src/*.o

# Build output in another output dir
make O=out kbuild_defconfig
make O=out menuconfig
make O=out or cd out && make

# output all cmd exectution and redirect to out.log
make V=1 SHELL="sh -x" 2>&1 | tee out.log


=== 6 Usage

--- 1. Kbuild user
For normal user who develops their modules (libraries) should not modify top Makefiles or Makefiles under scripts.
Create a Makefile for goal definition for a library is the case for kbuild user. Customized cflags can be specified
in module's Makefile.

--- 2. Kbuild developer
The build targets, rules and SDK automatio build flow are specified in top Makefiles or Makefiles under scripts.
Only Kbuild developer will modify it. Please don't edit it unless you clearly understand it.

=== 7 Known issues

1. "make" always triggers linking of ambacamera.out although without re-compiling libraries.
2. Error while "make distclean" or "make clean" without .config exists.

